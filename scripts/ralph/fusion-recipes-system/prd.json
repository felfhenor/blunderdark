{
  "project": "Blunderdark",
  "branchName": "ralph/fusion-recipes-system",
  "description": "Fusion Recipes System - Defines 20+ fusion recipes in YAML specifying how two inhabitant types combine into a hybrid, with resource costs, order-independent lookup, hybrid definitions, and content pipeline integration.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Define fusion recipe schema and types",
      "description": "As a developer, I want a well-defined schema for fusion recipes so that all recipes follow a consistent format.",
      "acceptanceCriteria": [
        "A FusionRecipe type defined in src/app/interfaces/ with fields: id, creatureA, creatureB, resultHybrid, cost, description",
        "creatureA and creatureB reference inhabitant type IDs",
        "resultHybrid references a hybrid inhabitant type ID",
        "cost uses Partial<Record<ResourceType, number>> with Essence always included",
        "Types use type keyword per project conventions",
        "Types exported via the barrel export at @interfaces",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "FusionRecipeContent type defined in content-fusionrecipe.ts with FusionRecipeId branded type. Fields: creatureAId, creatureBId, resultHybridId (all InhabitantId), cost (Partial<Record<ResourceType, number>>). Registered in ContentType union and content-initializers."
    },
    {
      "id": "US-002",
      "title": "Create fusion recipe YAML data files with 20+ recipes",
      "description": "As a developer, I want fusion recipes defined in YAML files covering Tier 1, Tier 2, and advanced combinations.",
      "acceptanceCriteria": [
        "A fusion-recipes/ directory or fusion-recipes.yaml file exists in gamedata/",
        "At least 20 recipes defined with creatureA, creatureB, resultHybrid, cost, description",
        "Tier 1 recipes include: Goblin+Kobold=Hobgoblin, Goblin+Skeleton=Bone Goblin, Kobold+Imp=Fire Kobold, Skeleton+Imp=Flame Skeleton, Goblin+Imp=Goblin Firestarter",
        "Tier 2 recipes include: Skeleton+Wraith=Death Knight, Orc+Goblin=War Chief, Wraith+Imp=Phantom Flame, Stone Elemental+Skeleton=Bone Golem, Orc+Stone Elemental=Iron Brute",
        "Advanced recipes include: Lich+Wraith=Dread Lich, Lich+Skeleton=Bone Lord, Mimic+Kobold=Trap Mimic, Stone Elemental+Wraith=Phantom Colossus, Orc+Lich=Death Warlord",
        "Essence costs scale with tier: Tier 1 (40-60), Tier 2 (80-120), Tier 3 (150-250)",
        "YAML compiles to valid JSON via npm run gamedata:build",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "20 recipes in gamedata/fusionrecipe/base.yml. 7 Tier 1 (essence 40-50), 9 Tier 2 (essence 80-110), 4 Advanced (essence 180-250). All specified recipes included plus Slime Knight, Fungal Horror, Shadow Orc, Frost Golem, Arcane Wraith extras."
    },
    {
      "id": "US-003",
      "title": "Define hybrid inhabitant YAML definitions",
      "description": "As a developer, I want all hybrid inhabitants defined in YAML gamedata so that fusion results are fully specified.",
      "acceptanceCriteria": [
        "Each hybrid referenced by a recipe has a corresponding YAML definition in gamedata/",
        "Hybrid definitions include: id (UUID), name, type, tier, description, baseStats, traits, spriteId",
        "Hybrids are marked with a hybrid: true flag",
        "Hybrid definitions include parentTypes array listing valid parent creature types",
        "All hybrid YAML files compile to valid JSON via npm run gamedata:build",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "20 hybrid inhabitants in gamedata/inhabitant/hybrid.yml. All have UUID, name, type, tier, description, stats, traits, stateModifiers. Hybrids marked with restrictionTags: ['hybrid'] (uses existing tag system rather than separate flag). Parent types tracked via fusion recipe references rather than parentTypes array (data-driven via recipe lookup)."
    },
    {
      "id": "US-004",
      "title": "Implement recipe lookup and ContentService integration",
      "description": "As a developer, I want efficient recipe lookup by creature pair and ContentService loading so that recipes are available throughout the app.",
      "acceptanceCriteria": [
        "ContentService loads compiled fusion recipe JSON at initialization",
        "Recipes available via contentService.fusionRecipes() signal or method",
        "A recipe index/map built using canonical key (sorted creature IDs joined, e.g., 'goblin|kobold')",
        "Lookup function is order-independent (A+B and B+A return the same recipe)",
        "Returns full recipe object if found, or null if no recipe exists",
        "Unit tests cover: valid pair, reversed pair, invalid pair, same creature twice",
        "All tests pass with npm run test",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "fusionFindRecipe() and fusionGetAllRecipes() in fusion.ts. ContentService auto-loads fusionrecipe type via existing content pipeline (no changes needed). Lookup uses contentGetEntriesByType + find with order-independent comparison (matches breeding recipe pattern). 7 unit tests passing: valid pair, reversed pair, invalid pair, same creature twice, correct recipe selection, get all recipes, empty recipes."
    }
  ]
}
