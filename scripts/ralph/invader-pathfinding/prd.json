{
  "project": "Blunderdark",
  "branchName": "ralph/invader-pathfinding",
  "description": "Invader Pathfinding - A* pathfinding on the dungeon's room/hallway connection graph for invader navigation, with morale-based fear detours, secondary objectives, and dynamic path recalculation.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Build connection graph representation",
      "description": "As a developer, I want a graph representation of dungeon rooms and hallways so that pathfinding can operate on it.",
      "acceptanceCriteria": [
        "Graph structure where rooms and hallway segments are nodes, edges represent connections",
        "Each edge has a traversal cost (default 1, modified by room properties)",
        "Graph updates when rooms or hallways are added/removed",
        "Graph uses adjacency list for lightweight representation",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "DungeonGraph with PathNode (rooms) and PathEdge (connections/hallways). buildDungeonGraph(floor, fearLevels) builds adjacency list from Floor data."
    },
    {
      "id": "US-002",
      "title": "Implement A* pathfinding with fear-based cost modification",
      "description": "As a developer, I want A* pathfinding that finds optimal paths from spawn to Altar with fear-based cost adjustments.",
      "acceptanceCriteria": [
        "A* algorithm operates on the connection graph with Manhattan distance heuristic",
        "Returns ordered list of nodes from start to goal, or empty path if none exists",
        "High-fear rooms increase traversal cost: invaders compare morale vs fear level",
        "Failed morale check multiplies room cost (e.g., 3x), making alternate routes preferred",
        "If no alternate route exists, invaders traverse the high-fear room regardless",
        "Algorithm handles graphs up to 400 nodes efficiently",
        "Helper in src/app/helpers/pathfinding.ts",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Uses Dijkstra (h=0) instead of A* with Manhattan because rooms connect at arbitrary distances via hallways, making Manhattan inadmissible. Fear cost = baseCost * 3 when morale < fearLevel."
    },
    {
      "id": "US-003",
      "title": "Implement secondary objective detours and dynamic recalculation",
      "description": "As a developer, I want invaders to detour to secondary objectives and recalculate paths when blocked.",
      "acceptanceCriteria": [
        "Invaders check if secondary objectives (Vault, Throne) are reachable within detour threshold",
        "Detour threshold: path to secondary + path to Altar must be less than 2x direct path",
        "Some invader types prioritize secondary objectives (thieves target Vault)",
        "If next node is blocked, path is recalculated with updated graph state",
        "If no valid path after recalculation, invader enters 'confused' state (skips turn)",
        "Recalculation completes within one frame",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "findPathWithObjectives() selects highest-priority secondary within 2x threshold. recalculatePath() adds blocked node and re-runs Dijkstra. Empty path = confused state."
    },
    {
      "id": "US-004",
      "title": "Write pathfinding unit tests",
      "description": "As a developer, I want comprehensive tests for invader pathfinding so that correctness is verified.",
      "acceptanceCriteria": [
        "Test: Direct path from spawn to altar on simple linear dungeon",
        "Test: Path around an obstacle (blocked room)",
        "Test: No valid path returns empty array",
        "Test: Fear-based cost modification produces longer but safer paths",
        "Test: Path recalculation after blocking a node",
        "Tests in src/app/helpers/pathfinding.spec.ts",
        "All tests pass with npm run test",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "39 tests covering graph building, basic pathfinding, fear costs, secondary objectives, dynamic recalculation, and complex graph scenarios."
    }
  ]
}
